<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <link rel='stylesheet' href='css/common.css'>
    <title>Hit Test with Anchors</title>
    <script src="https://cdn.jsdelivr.net/npm/resonance-audio/build/resonance-audio.min.js"></script>
  </head>
  <body>
    <header>
      <details open>
        <summary>Hit Test with Anchors</summary>
        <p>This demo shows hit testing, anchors, and positional audio with scaling visuals. <a class="back" href="./">Back</a></p>
      </details>
    </header>
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {vec3} from './js/render/math/gl-matrix.js';

      let xrButton = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;

      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.enableStats(false);

      let reticle = new Gltf2Node({url: 'media/gltf/reticle/reticle.gltf'});
      reticle.visible = false;
      scene.addNode(reticle);
      let reticleHitTestResult = null;

      const audioContext = new AudioContext();
      const resonance = new ResonanceAudio(audioContext);
      resonance.output.connect(audioContext.destination);
      audioContext.suspend();

      const ANALYSER_FFT_SIZE = 1024;
      let fftBuffer = new Float32Array(ANALYSER_FFT_SIZE);

      function getLoudnessScale(analyser) {
        analyser.getFloatTimeDomainData(fftBuffer);
        let sum = 0;
        for (let i = 0; i < fftBuffer.length; ++i)
          sum += fftBuffer[i] * fftBuffer[i];
        let rms = Math.sqrt(sum / fftBuffer.length);
        let db = 30 + 10 / Math.LN10 * Math.log(rms <= 0 ? 0.0001 : rms);
        analyser.lastRMSdB ??= 0;
        analyser.lastRMSdB += 0.525 * ((db < 0 ? 0 : db) - analyser.lastRMSdB);
        return Math.max(0.3, analyser.lastRMSdB / 30.0);
      }

      let audioBuffer = null;
      fetch('media/sound/beep.mp3')
        .then(r => r.arrayBuffer())
        .then(ab => audioContext.decodeAudioData(ab))
        .then(decoded => { audioBuffer = decoded; })
        .catch(console.error);

      function createAudioSource(position) {
        if (audioContext.state === 'suspended') audioContext.resume();

        const source3d = resonance.createSource();
        source3d.setPosition(...position);

        const bufferSource = audioContext.createBufferSource();
        bufferSource.buffer = audioBuffer;
        bufferSource.loop = true;

        const analyser = audioContext.createAnalyser();
        analyser.fftSize = ANALYSER_FFT_SIZE;

        bufferSource.connect(analyser);
        analyser.connect(source3d.input);

        bufferSource.start();

        return {bufferSource, source3d, analyser};
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {requiredFeatures: ['local', 'hit-test', 'anchors']})
                           .then(onSessionStarted);
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        if (!gl) {
          gl = createWebGLContext({ xrCompatible: true });
          renderer = new Renderer(gl);
          scene.setRenderer(renderer);
        }

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        session.requestReferenceSpace('viewer').then(space => {
          xrViewerSpace = space;
          return session.requestHitTestSource({ space });
        }).then(hitTestSource => {
          xrHitTestSource = hitTestSource;
        });

        session.requestReferenceSpace('local').then(space => {
          xrRefSpace = space;
          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onEndSession(session) {
        anchoredObjects.forEach(o => o.audioSource.bufferSource.stop());
        anchoredObjects.length = 0;
        xrHitTestSource?.cancel();
        xrHitTestSource = null;
        session.end();
      }

      function onSessionEnded() {}

      const MAX_ANCHORED_OBJECTS = 10;
      let anchoredObjects = [];

      function addAnchoredObjectsToScene(anchor, position) {
        let stereo = new Gltf2Node({url: 'media/gltf/stereo/stereo.gltf'});
        scene.addNode(stereo);
        const audioSource = createAudioSource(position);

        anchoredObjects.push({ anchoredObject: stereo, anchor, audioSource });

        if (anchoredObjects.length > MAX_ANCHORED_OBJECTS) {
          const old = anchoredObjects.shift();
          old.audioSource.bufferSource.stop();
          scene.removeNode(old.anchoredObject);
          old.anchor.delete();
        }
      }

      function onSelect() {
        if (!reticle.visible) return;
        const pose = reticleHitTestResult.getPose(xrRefSpace).transform.position;
        reticleHitTestResult.createAnchor().then(anchor => {
          addAnchoredObjectsToScene(anchor, [pose.x, pose.y, pose.z]);
        }).catch(console.error);
      }

      function onXRFrame(t, frame) {
        const session = frame.session;
        const viewerPose = frame.getViewerPose(xrRefSpace);

        if (viewerPose) {
          const pos = viewerPose.transform.position;
          const orient = viewerPose.transform.orientation;
          resonance.setListenerPosition(pos.x, pos.y, pos.z);
          resonance.setListenerOrientation(orient.x, orient.y, orient.z, orient.w);
        }

        reticle.visible = false;
        if (xrHitTestSource && viewerPose) {
          const hits = frame.getHitTestResults(xrHitTestSource);
          if (hits.length > 0) {
            const hitPose = hits[0].getPose(xrRefSpace);
            reticle.visible = true;
            reticle.matrix = hitPose.transform.matrix;
            reticleHitTestResult = hits[0];
          }
        }

        for (let obj of anchoredObjects) {
          const ap = frame.getPose(obj.anchor.anchorSpace, xrRefSpace);
          if (!ap) continue;

          obj.anchoredObject.matrix = ap.transform.matrix;

          const pos = [
            ap.transform.matrix[12],
            ap.transform.matrix[13],
            ap.transform.matrix[14],
          ];
          obj.audioSource.source3d.setPosition(...pos);

          const scale = getLoudnessScale(obj.audioSource.analyser);
          const m = obj.anchoredObject.matrix;
          m[0] *= scale; m[1] *= scale; m[2] *= scale;
          m[4] *= scale; m[5] *= scale; m[6] *= scale;
          m[8] *= scale; m[9] *= scale; m[10] *= scale;
        }

        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);
        scene.drawXRFrame(frame, viewerPose);
        scene.endFrame();
      }

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession,
          onEndSession,
          textEnterXRTitle: "ENTER AR",
          textXRNotFoundTitle: "XR NOT SUPPORTED",
          textExitXRTitle: "EXIT AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar')
                      .then((supported) => {
            xrButton.enabled = supported;
          });
        }
      }

      initXR();
    </script>
  </body>
</html>
